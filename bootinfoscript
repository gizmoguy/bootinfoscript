#!/bin/bash
VERSION='0.78';
RELEASE_DATE='09 October 2019';
LAST_GIT_COMMIT_SHORTLOG='';
LAST_GIT_COMMIT_DATE='';
################################################################################
#                                                                              #
# Copyright (c) 2009-2010      Ulrich Meierfrankenfeld                         #
# Copyright (c) 2011-2012      Gert Hulselmans                                 #
# Copyright (c) 2013-2018      Andrei Borzenkov                                #
#                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy #
# of this software and associated documentation files (the "Software"), to     #
# deal in the Software without restriction, including without limitation the   #
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  #
# sell copies of the Software, and to permit persons to whom the Software is   #
# furnished to do so, subject to the following conditions:                     #
#                                                                              #
# The above copyright notice and this permission notice shall be included in   #
# all copies or substantial portions of the Software.                          #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      #
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS #
# IN THE SOFTWARE.                                                             #
#                                                                              #
################################################################################
#                                                                              #
# Current developer:  Andrei Borzenkov                                         #
#                                                                              #
# Past developer:     Gert Hulselmans                                          #
# Past developer:     Ulrich Meierfrankenfeld (meierfra) (ubuntuforums.org)    #
# Past contributor:   caljohnsmith (ubuntuforums.org)                          #
#                                                                              #
# Hosted at:          https://github.com/arvidjaar/bootinfoscript              #
# Forked from:        http://sourceforge.net/projects/bootinfoscript/          #
#                                                                              #
# The birth of Boot Info Script:                                               #
#                     http://ubuntuforums.org/showthread.php?t=837791          #
#                                                                              #
# Tab width:          8 spaces                                                 #
#                                                                              #
################################################################################



## Check if the script is run with bash as shell interpreter.

if [ -z "$BASH_VERSION" ] ; then
   echo 'Boot Info Script needs to be run with bash as shell interpreter.' >&2;
   exit 1;
fi



## Display help text ##
#
#   ./bootinfoscript -h
#   ./bootinfoscript -help
#   ./bootinfoscript --help
 
help () {
   cat <<- HELP
	
	Usage Boot Info Script:
	-----------------------
	
	  Run the script as sudoer:
	
	    sudo ${0} <outputfile>
	
	  or if your operating system does not use sudo:
	
	    su -
	    ${0} <outputfile>
	
	
	  When running the script, without specifying an output file, all the output
	  is written to the file "RESULTS.txt" in the same folder as the script.
	
	  But when run from /bin, /sbin, /usr/bin, or another system folder, the file
	  "RESULTS.txt" is written to the home directory of the user.
	
	  When the file "RESULTS.txt" already exists, the results will be written to
	  "RESULTS1.txt". If "RESULTS1.txt" exists, the results will be written to
	  "RESULTS2.txt", ...
	
	
	  To get version number, release date, last git commit and git retrieval date
	  of this script, use (no root rights needed):
	
	    ${0} -v
	    ${0} -V
	    ${0} --version
	
	
	  To get this help text, use (no root rights needed):
	
	    ${0} -h
	    ${0} -help
	    ${0} --help
	
		
	  To automatically gzip a copy of the output file, use (root rights needed):
	
	    ${0} -g <outputfile>
	    ${0} --gzip <outputfile>
	
		
	  To write the output to stdout instead of a file, use (root rights needed):
	
	    ${0} --stdout
	
	
	  The last development version of Boot Info Script can be downloaded, with:
	    (no root rights needed)
	
	    ${0} --update <filename>
	
	  If no filename is specified, the file will be saved in the home dir as
	  "bootinfoscript_YYYY-MM-DD_hh:mm:ss".
	
	HELP

   exit 0;
}



## Download the last development version of BIS from git: ##
#
#   ./bootinfoscript --update <filename>
#
#   If no filename is specified, the file will be saved in the home dir as
#   "bootinfoscript_YYYY-MM-DD_hh:mm:ss".

update () {
  local git_ref_url='https://api.github.com/repos/arvidjaar/bootinfoscript/git/refs/heads/master'
  local git_commit_url='https://api.github.com/repos/arvidjaar/bootinfoscript/git/commits'
  local git_contents_url='https://github.com/arvidjaar/bootinfoscript/raw/master/bootinfoscript'

  # Check if date is available.
  if [ $(type date > /dev/null 2>&1 ; echo $?) -ne 0 ] ; then
     echo '"date" could not be found.' >&2;
     exit 1;
  fi

  # Get current UTC time in YYYY-MM-DD-hh:mm:ss format.
  UTC_TIME=$(date --utc "+%Y-%m-%d %T");

  if [ ! -z "$1" ] ; then
     GIT_BIS_FILENAME="$1";
  else
     GIT_BIS_FILENAME="${HOME}/bootinfoscript_${UTC_TIME/ /_}"
  fi

  # Check if wget or curl is available
  if [ $(type wget > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
     printf '\nDownloading last development version of Boot Info Script from git:\n\n';
     LAST_GIT_COMMIT_ID=$(wget -O - "${git_ref_url}" | sed -ne 's/^.*"sha": "\(.*\)".*$/\1/p');
     LAST_GIT_COMMIT=$(wget -O - "${git_commit_url}/$LAST_GIT_COMMIT_ID");

     wget -O "${GIT_BIS_FILENAME}" "${git_contents_url}";
  elif [ $(type curl > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
     printf 'Downloading last development version of Boot Info Script from git:\n\n';
     LAST_GIT_COMMIT_ID=$(curl "${git_ref_url}" | sed -ne 's/^.*"sha": "\(.*\)".*$/\1/p');
     LAST_GIT_COMMIT=$(curl "${git_commit_url}/$LAST_GIT_COMMIT_ID");

     curl -o "${GIT_BIS_FILENAME}" "${git_contents_url}";
  else
     printf '"wget" or "curl" could not be found.\nInstall at least one of them and try again.\n' >&2;
     exit 1;
  fi

  # First date is Author, second date is Commit
  LAST_GIT_COMMIT_DATE=$(echo "${LAST_GIT_COMMIT}" | sed -ne 's/^[[:space:]]*"date": "\(.*\)"[[:space:]]*$/\1/p' | tail -1);
  LAST_GIT_COMMIT_SHORTLOG=$(echo "${LAST_GIT_COMMIT}" | sed -n -e '/^[[:space:]]*"message":/ { s/^[[:space:]]*"message": "\(.*\)",[[:space:]]*$/\1/ ; s/\\n.*$// ; p }');

  # Set the retrieval date in just downloaded script.
  sed -i -e "4,0 s@LAST_GIT_COMMIT_SHORTLOG='';@LAST_GIT_COMMIT_SHORTLOG='${LAST_GIT_COMMIT_SHORTLOG}';@" \
	 -e "5,0 s/LAST_GIT_COMMIT_DATE='';/LAST_GIT_COMMIT_DATE='${LAST_GIT_COMMIT_DATE}';/" \
	 "${GIT_BIS_FILENAME}";

  printf '\nThe development version of Boot Info Script is saved as:\n"%s"\n\n' "${GIT_BIS_FILENAME}";
  exit 0;
}



## Display version, release, last git commit and git retrieval date of the script when asked: ##
#
#   ./bootinfoscript -v
#   ./bootinfoscript -V
#   ./bootinfoscript --version 

version () {
  printf '\nBoot Info Script version: %s\nRelease date:             %s' "${VERSION}" "${RELEASE_DATE}";

  if [ ! -z "${LAST_GIT_COMMIT_SHORTLOG}" ] ; then
     printf '\nLast git commit:          %s\nCommit date:              %s' \
            "${LAST_GIT_COMMIT_SHORTLOG}" "${LAST_GIT_COMMIT_DATE}";
  fi

  printf '\n\n';

  exit 0;
}



## Gzip a copy of the output file? ##
gzip_output=0;	 # off=0

## Write the output to the standard output instead of to a file? ##
stdout_output=1; # on=1



## Get arguments passed to the script. ##

process_args () {
  if [ ${#@} -ge 1 ] ; then
     # Process arguments.
     case "$1" in
	-g	  ) gzip_output=1; if [ ! -z "$2" ] ; then LogFile_cmd="$2"; fi;;
	--gzip	  ) gzip_output=1; if [ ! -z "$2" ] ; then LogFile_cmd="$2"; fi;;
	-h	  ) help;;
	-help	  ) help;;
	--help	  ) help;;
	--stdout  ) stdout_output=1;;
	--update  ) update "$2";;
	-v	  ) version;;
	-V	  ) version;;
	--version ) version;;
	-*	  ) help;;
	*	  ) LogFile_cmd="$1";;
     esac
  fi
}




## Get arguments passed to the script. ##

process_args ${@};



## Display version number, release and git retrieval date. ##

printf '\nBoot Info Script %s      [%s]' "${VERSION}" "${RELEASE_DATE}";

if [ ! -z "${LAST_GIT_COMMIT_SHORTLOG}" ] ; then
   printf '\n  Last git commit:         %s\n  Commit date:             %s' \
          "${LAST_GIT_COMMIT_SHORTLOG}" "${LAST_GIT_COMMIT_DATE}";
fi

printf '\n\n';



## Check whether Boot Info Script is run with root rights or not. ##

if [ $(type whoami > /dev/null 2>&1 ; echo $?) -ne 0 ] ; then
   echo 'Please install "whoami" and run Boot Info Script again.' >&2;
   exit 1;
elif [ $(whoami) != 'root' ] ; then
   cat <<- EOF >&2
	Please use "sudo" or become "root" to run this script.
	
	  Run the script as sudoer:
	
	    sudo ${0} <outputfile>
	
	  or if your operating system does not use sudo:
	
	    su -
	    ${0} <outputfile>

	For more info, see the help:

	    ${0} --help
	
	EOF
   exit 1;
fi



## Check if all necessary programs are available. ##

# Programs that are in /bin or /usr/bin.
Programs='
	basename
	cat
	chown
	dd
	dirname
	expr
	fold
	grep
	gzip
	hexdump
	ls
	mkdir
	mktemp
	mount
	printf
	pwd
	rm
	sed
	sort
	tr
	umount
	wc'

# Programs that are in /usr/sbin or /sbin.
Programs_SBIN='
	blkid
	fdisk
	filefrag
	losetup'


Check_Prog=1;

for Program in ${Programs} ${Programs_SBIN}; do
  if [ $(type ${Program} > /dev/null 2>&1 ; echo $?) -ne 0 ] ; then
     echo "\"${Program}\" could not be found." >&2;
     Check_Prog=0;
  fi
done



## Can we decompress a LZMA stream? ##
#
#   The Grub2 (v1.99-2.00) core_dir string is contained in a LZMA stream.
#   See if we have xz or lzma installed to decompress the stream.
#

if [ $(type xz > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
   UNLZMA='xz --format=lzma --decompress';
elif [ $(type lzma > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
   UNLZMA='lzma -cd';
else
   UNLZMA='none';
fi



## Do we have gawk or (a recent) mawk? ##
#
#   If we don't have gawk, look for "mawk v1.3.4" or newer.
#

if [ $(type gawk > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
   # Set awk binary to gawk.
   AWK='gawk';
elif [ $(type mawk > /dev/null 2>&1 ; echo $?) -eq 0 ] ; then
   MAWK_version="$(mawk -W version 2>&1)";
   MAWK_version="${MAWK_version:0:10}";

   if [ "${MAWK_version}" = 'mawk 1.3.3' ]; then
      printf '"mawk v1.3.3" has known bugs.\nInstall "mawk v1.3.4" or newer from http://invisible-island.net/mawk/ or use "gawk" instead.\n' >&2;
	  Check_Prog=0;
   else
      # Set awk binary to mawk (version 1.3.4 or higher).
      AWK='mawk';
   fi
else
   printf 'Install "gawk" or "mawk v1.3.4" (or newer) from http://invisible-island.net/mawk/.\n' >&2;
   Check_Prog=0;
fi



if [ ${Check_Prog} -eq 0 ] ; then
   printf '\nPlease install the missing program(s) and run Boot Info Script again.\n' >&2;
   exit 1;
fi



## List of folders which might contain files used for chainloading. ##

Boot_Codes_Dir='
	/
	/NST/
	'



## List of files whose names will be displayed, if found. ##

Boot_Prog_Normal='
	/bootmgr	/BOOTMGR
	/boot/bcd	/BOOT/bcd	/Boot/bcd	/boot/BCD	/BOOT/BCD	/Boot/BCD
	/Windows/System32/winload.exe	/WINDOWS/system32/winload.exe	/WINDOWS/SYSTEM32/winload.exe	/windows/system32/winload.exe
	/Windows/System32/Winload.exe	/WINDOWS/system32/Winload.exe	/WINDOWS/SYSTEM32/Winload.exe	/windows/system32/Winload.exe
	/grldr		/GRLDR		/grldr.mbr	/GRLDR.MBR
	/ntldr		/NTLDR
	/NTDETECT.COM	/ntdetect.com
	/NTBOOTDD.SYS	/ntbootdd.sys
	/wubildr	/ubuntu/winboot/wubildr
	/wubildr.mbr	/ubuntu/winboot/wubildr.mbr
	/ubuntu/disks/root.disk
	/ubuntu/disks/home.disk
	/ubuntu/disks/swap.disk
	/core.img	/grub/core.img	/boot/grub/core.img
	/grub/i386-pc/core.img		/boot/grub/i386-pc/core.img
	/grub2/core.img			/boot/grub2/core.img
	/grub2/i386-pc/core.img		/boot/grub2/i386-pc/core.img
	/burg/core.img	/boot/burg/core.img
	/ldlinux.sys	/syslinux/ldlinux.sys	/boot/syslinux/ldlinux.sys
	/extlinux.sys	/extlinux/extlinux.sys	/boot/extlinux/extlinux.sys
	/boot/map	/map
	/DEFAULT.MNU	/default.mnu
	/IO.SYS		/io.sys
	/MSDOS.SYS	/msdos.sys 
	/KERNEL.SYS	/kernel.sys
	/DELLBIO.BIN	/dellbio.bin		/DELLRMK.BIN	/dellrmk.bin
	/COMMAND.COM	/command.com
	'

Boot_Prog_Fat='
	/bootmgr
	/boot/bcd
	/Windows/System32/winload.exe
	/grldr
	/grldr.mbr
	/ntldr
	/freeldr.sys
	/NTDETECT.COM
	/NTBOOTDD.SYS
	/wubildr
	/wubildr.mbr
	/ubuntu/winboot/wubildr
	/ubuntu/winboot/wubildr.mbr
	/ubuntu/disks/root.disk
	/ubuntu/disks/home.disk
	/ubuntu/disks/swap.disk
	/core.img	/grub/core.img		/boot/grub/core.img
	/grub/i386-pc/core.img			/boot/grub/i386-pc/core.img
	/grub2/core.img				/boot/grub2/core.img
	/grub2/i386-pc/core.img			/boot/grub2/i386-pc/core.img
	/burg/core.img	/boot/burg/core.img
	/ldlinux.sys	/syslinux/ldlinux.sys	/boot/syslinux/ldlinux.sys
	/extlinux.sys	/extlinux/extlinux.sys	/boot/extlinux/extlinux.sys
	/boot/map	/map
	/DEFAULT.MNU
	/IO.SYS
	/MSDOS.SYS
	/KERNEL.SYS
	/DELLBIO.BIN	/DELLRMK.BIN
	/COMMAND.COM
	'



## List of files whose contents will be displayed. ##

Boot_Files_Normal='
	/menu.lst	/grub/menu.lst	/boot/grub/menu.lst	/NST/menu.lst	
	/grub.cfg	/grub/grub.cfg	/boot/grub/grub.cfg	/grub2/grub.cfg	/boot/grub2/grub.cfg
	/custom.cfg	/grub/custom.cfg	/boot/grub/custom.cfg	/grub2/custom.cfg	/boot/grub2/custom.cfg
	/burg.cfg	/burg/burg.cfg	/boot/burg/burg.cfg
	/grub.conf	/grub/grub.conf	/boot/grub/grub.conf	/grub2/grub.conf	/boot/grub2/grub.conf
	/ubuntu/disks/boot/grub/menu.lst	/ubuntu/disks/install/boot/grub/menu.lst	/ubuntu/winboot/menu.lst
	/boot.ini	/BOOT.INI	/Boot.ini
	/etc/fstab
	/etc/lilo.conf	/lilo.conf
	/syslinux.cfg	/syslinux/syslinux.cfg	/boot/syslinux/syslinux.cfg
	/extlinux.conf	/extlinux/extlinux.conf	/boot/extlinux/extlinux.conf
	/grldr		/grub.exe
	'

Boot_Files_Fat='
	/menu.lst	/grub/menu.lst	/boot/grub/menu.lst	/NST/menu.lst
	/grub.cfg	/grub/grub.cfg	/boot/grub/grub.cfg	/grub2/grub.cfg	/boot/grub2/grub.cfg
	/custom.cfg	/grub/custom.cfg	/boot/grub/custom.cfg	/grub2/custom.cfg	/boot/grub2/custom.cfg
	/burg.cfg	/burg/burg.cfg	/boot/burg/burg.cfg
	/grub.conf	/grub/grub.conf	/boot/grub/grub.conf	/grub2/grub.conf	/boot/grub2/grub.conf
	/ubuntu/disks/boot/grub/menu.lst	/ubuntu/disks/install/boot/grub/menu.lst	/ubuntu/winboot/menu.lst
	/boot.ini
	/freeldr.ini
	/etc/fstab
	/etc/lilo.conf	/lilo.conf
	/syslinux.cfg	/syslinux/syslinux.cfg	/boot/syslinux/syslinux.cfg
	/extlinux.conf	/extlinux/extlinux.conf	/boot/extlinux/extlinux.conf
	/grldr		/grub.exe
	'


## List of files whose end point (in GiB / GB) will be displayed. ##

GrubError18_Files='
	menu.lst	grub/menu.lst	boot/grub/menu.lst	NST/menu.lst
	ubuntu/disks/boot/grub/menu.lst
	grub.conf	grub/grub.conf	boot/grub/grub.conf	grub2/grub.conf	boot/grub2/grub.conf
	grub.cfg	grub/grub.cfg	boot/grub/grub.cfg	grub2/grub.cfg	boot/grub2/grub.cfg
	burg.cfg	burg/burg.cfg	boot/burg/burg.cfg
	core.img	grub/core.img	boot/grub/core.img
	grub/i386-pc/core.img		boot/grub/i386-pc/core.img
	grub2/core.img			boot/grub2/core.img
	grub2/i386-pc/core.img		boot/grub2/i386-pc/core.img
	burg/core.img	boot/burg/core.img
	stage2		grub/stage2	boot/grub/stage2
	boot/vmlinuz*	vmlinuz*	ubuntu/disks/boot/vmlinuz*
	boot/initrd*	initrd*		ubuntu/disks/boot/initrd*
	boot/kernel*.img
	initramfs*	boot/initramfs*
	'

SyslinuxError_Files='
	syslinux.cfg	syslinux/syslinux.cfg	boot/syslinux/syslinux.cfg
	extlinux.conf	extlinux/extlinux.conf	boot/extlinux/extlinux.conf
	ldlinux.sys	syslinux/ldlinux.sys	boot/syslinux/ldlinux.sys
	extlinux.sys	extlinux/extlinux.sys	boot/extlinux/extlinux.sys
	*.c32		syslinux/*.c32			boot/syslinux/*.c32
	extlinux/*.c32	boot/extlinux/*.c32
	'



## Set output filename ##

if [ ${stdout_output} -eq 1 ] ; then
  # The LogFile name is not used when --stdout is specified.
  LogFile="";
fi



## Redirect stdout to RESULT File ##
#
#   exec 6>&1   
#   exec > "${LogFile}"



## Create temporary directory ##

Folder=$(mktemp -t -d BootInfo-XXXXXXXX);



## Create temporary filenames. ##

cd ${Folder}
Log=${Folder}/Log				# File to record the summary.
Log1=${Folder}/Log1				# Most of the information which is not part of
						# the summary is recorded in this file.
Error_Log=${Folder}/Error_Log			# File to catch all unusal Standar Errors.
Trash=${Folder}/Trash				# File to catch all usual Standard Errors these
						# messagges will not be included in the RESULTS.
Mount_Error=${Folder}/Mount_Error		# File to catch Mounting Errors.
Unknown_MBR=${Folder}/Unknown_MBR		# File to record all unknown MBR and Boot sectors.
Tmp_Log=${Folder}/Tmp_Log			# File to temporarily hold some information.
core_img_file=${Folder}/core_img		# File to temporarily store an embedded core.img of grub2.
core_img_file_unlzma=${Folder}/core_img_unlzma	# File to temporarily store the uncompressed part of core.img of grub2.
core_img_file_type_2=${Folder}/core_img_type_2	# File to temporarily store the core.img module of type 2
PartitionTable=${Folder}/PT			# File to store the Partition Table.
FakeHardDrives=${Folder}/FakeHD			# File to list devices which seem to have  no corresponding drive.
BLKID=${Folder}/BLKID				# File to store the output of blkid.
GRUB200_Module=${Folder}/GRUB200_Module		# File to store current grub2 module




## List of all hard drives ##
#
#   Support more than 26 drives.

All_Hard_Drives=$(ls /dev/hd[a-z] /dev/hd[a-z][a-z] /dev/sd[a-z] /dev/sd[a-z][a-z] /dev/xvd[a-z] /dev/vd[a-z] /dev/vd[a-z][a-z] 2>> ${Trash});


## Add found RAID disks to list of hard drives. ##

if [ $(type dmraid >> ${Trash} 2>> ${Trash} ; echo $?) -eq 0 ] ; then
  InActiveDMRaid=$(dmraid -si -c);

  if [ x"${InActiveDMRaid}" = x"no raid disks" ] || [ x"${InActiveDMRaid}" = x"no block devices found" ] ; then 
     InActiveDMRaid='';
  fi

  if [ x"${InActiveDMRaid}" != x'' ] ; then
     dmraid -ay ${InActiveDMRaid} >> ${Trash};
  fi

  All_DMRaid=$(dmraid -sa -c);
  if [ x"${All_DMRaid}" != x"no raid disks" ] && [ x"${All_DMRaid}" != x"no block devices found" ] ; then
     All_DMRaid=$(echo "{All_DMRaid}" | ${AWK} '{ print "/dev/mapper/"$0 }');
     All_Hard_Drives="${All_Hard_Drives} ${All_DMRaid}";
  fi  
fi



## Arrays to hold information about Partitions: ##
#
#   name, starting sector, ending sector, size in sector, partition type,
#   filesystem type, UUID, kind(Logical, Primary, Extended), harddrive,
#   boot flag,  parent (for logical partitions), label,
#   system(the partition id according the partition table),
#   the device associated with the partition.

declare -a NamesArray StartArray EndArray SizeArray TypeArray  FileArray UUIDArray KindArray DriveArray BootArray ParentArray LabelArray SystemArray DeviceArray;


## Arrays to hold information about the harddrives. ##

declare -a HDName FirstPartion LastPartition HDSize HDMBR HDHead HDTrack HDCylinder HDPT HDStart HDEnd HDUUID;


## Array for hard drives formatted as filesystem. ##

declare -a FilesystemDrives;



PI=-1;  ## Counter for the identification number of a partition.   (each partition gets unique number)   ##
HI=0;   ## Counter for the identification number of a hard drive.  (each hard drive gets unique number)  ##
PTFormat='%-10s %4s%14s%14s%14s %3s %s\n';	## standard format (hexdump) to use for partition table. ##



## Get total number of blocks on a device. ##
#
#   Sometimes "fdisk -s" seems to malfunction or isn't supported (busybox fdisk),
#   so use "sfdisk -s" if available.
#   If sfdisk isn't available, calculate the number of blocks from the number of
#   sectors (divide by 2).

fdisks () {
  if [ $(type sfdisk >> ${Trash} 2>> ${Trash} ; echo $?) -eq 0 ] ; then
     sfdisk -s "$1" 2>> ${Trash};
  else
     # Calculate the number of blocks from the number of sectors (divide by 2).
     fdisk -lu "$1" 2>> ${Trash} | ${AWK} '$0 ~ /, .*, .*, .*/ { print $(NF - 1) / 2 }';
  fi
}
   


##  A function which checks whether a file is on a mounted partition. ##

# List of mount points for devices: also allow mount points with spaces.

MountPoints=$(mount \
	      | ${AWK} -F "\t" '{ if ( ($1 ~ "^/dev") && ($3 != "/") ) { sub(" on ", "\t", $0); sub(" type ", "\t", $0); print $2 } }' \
	      | sort -u);


FileNotMounted () {	
  local File=$1 curmp=$2;

  IFS_OLD="${IFS}";  # Save original IFS.
  IFS=$'\012';       # Set IFS temporarily to newline only, so mount points with spaces can be processed too.

  for mp in ${MountPoints}; do 
    if [ $(expr match "${File}" "${mp}/" ) -ne 0 ] && [ "${mp}" != "${curmp}" ] ; then
       IFS="${IFS_OLD}";  # Restore original IFS.
       return 1;
    fi
  done

  IFS="${IFS_OLD}";       # Restore original IFS.
  return 0;
}



## Function which converts the two digit hexcode to the partition type. ##
#
#   The following list is taken from sfdisk -T and 
#   http://www.win.tue.nl/~aeb/partitions/partition_types-1.html
#   is work in progress.

HexToSystem () {
  local type=$1 system;

  case ${type} in
    0)  system='Empty';;
    1)  system='FAT12';;
    2)  system='XENIX root';;
    3)  system='XENIX /usr';;
    4)  system='FAT16 <32M';;
    5)  system='Extended';;
    6)  system='FAT16';;
    7)  system='NTFS / exFAT / HPFS';;
    8)  system='AIX bootable';;
    9)  system='AIX data';;
    a)  system='OS/2 Boot Manager';;
    b)  system='W95 FAT32';;
    c)  system='W95 FAT32 (LBA)';;
    e)  system='W95 FAT16 (LBA)';;
    f)  system='W95 Extended (LBA)';;
    10) system='OPUS';;
    11) system='Hidden FAT12';;
    12) system='Compaq diagnostics';;
    14) system='Hidden FAT16 < 32M';;
    16) system='Hidden FAT16';;
    17) system='Hidden NTFS / HPFS';;
    18) system='AST SmartSleep';;
    1b) system='Hidden W95 FAT32';;
    1c) system='Hidden W95 FAT32 (LBA)';;
    1e) system='Hidden W95 FAT16 (LBA)';;
    24) system='NEC DOS';;
    27) system='Hidden NTFS (Recovery Environment)';;
    2a) system='AtheOS File System';;
    2b) system='SyllableSecure';;
    32) system='NOS';;
    35) system='JFS on OS/2';;
    38) system='THEOS';;
    39) system='Plan 9';;
    3a) system='THEOS';;
    3b) system='THEOS Extended';;
    3c) system='PartitionMagic recovery';;
    3d) system='Hidden NetWare';;
    40) system='Venix 80286';;
    41) system='PPC PReP Boot';;
    42) system='SFS';;
    44) system='GoBack';;
    45) system='Boot-US boot manager';;
    4d) system='QNX4.x';;
    4e) system='QNX4.x 2nd part';;
    4f) system='QNX4.x 3rd part';;
    50) system='OnTrack DM';;
    51) system='OnTrack DM6 Aux1';;
    52) system='CP/M';;
    53) system='OnTrack DM6 Aux3';;
    54) system='OnTrack DM6 DDO';;
    55) system='EZ-Drive';;
    56) system='Golden Bow';;
    57) system='DrivePro';;
    5c) system='Priam Edisk';;
    61) system='SpeedStor';;
    63) system='GNU HURD or SysV';;
    64) system='Novell Netware 286';;
    65) system='Novell Netware 386';;
    70) system='DiskSecure Multi-Boot';;
    74) system='Scramdisk';;
    75) system='IBM PC/IX';;
    78) system='XOSL filesystem';;
    80) system='Old Minix';;
    81) system='Minix / old Linux';;
    82) system='Linux swap / Solaris';;
    83) system='Linux';;
    84) system='OS/2 hidden C: drive';;
    85) system='Linux extended';;
    86) system='NTFS volume set';;
    87) system='NTFS volume set';;
    88) system='Linux plaintext';;
    8a) system='Linux Kernel (AiR-BOOT)';;
    8d) system='Free FDISK hidden Primary FAT12';;
    8e) system='Linux LVM';;
    90) system='Free FDISK hidden Primary FAT16 <32M';;
    91) system='Free FDISK hidden Extended';;
    92) system='Free FDISK hidden Primary FAT16';;
    93) system='Amoeba/Accidently Hidden Linux';;
    94) system='Amoeba bad block table';;
    97) system='Free FDISK hidden Primary FAT32';;
    98) system='Free FDISK hidden Primary FAT32 (LBA)';;
    9a) system='Free FDISK hidden Primary FAT16 (LBA)';;
    9b) system='Free FDISK hidden Extended (LBA)';;
    9f) system='BSD/OS';;
    a0) system='IBM Thinkpad hibernation';;
    a1) system='Laptop hibernation';;
    a5) system='FreeBSD';;
    a6) system='OpenBSD';;
    a7) system='NeXTSTEP';;
    a8) system='Darwin UFS';;
    a9) system='NetBSD';;
    ab) system='Darwin boot';;
    af) system='HFS / HFS+';;
    b0) system='BootStar';;
    b1 | b3) system='SpeedStor / QNX Neutrino Power-Safe';;
    b2) system='QNX Neutrino Power-Safe';;
    b4 | b6) system='SpeedStor';; 
    b7) system='BSDI fs';;
    b8) system='BSDI swap';;
    bb) system='Boot Wizard hidden';;
    bc) system='Acronis BackUp';;
    be) system='Solaris boot';;
    bf) system='Solaris';;
    c0) system='CTOS';;
    c1) system='DRDOS / secured (FAT-12)';;
    c2) system='Hidden Linux (PowerBoot)';;
    c3) system='Hidden Linux Swap (PowerBoot)';;
    c4) system='DRDOS secured FAT16 < 32M';;
    c5) system='DRDOS secured Extended';;
    c6) system='DRDOS secured FAT16';;
    c7) system='Syrinx';;
    cb) system='DR-DOS secured FAT32 (CHS)';;
    cc) system='DR-DOS secured FAT32 (LBA)';;
    cd) system='CTOS Memdump?';;
    ce) system='DR-DOS FAT16X (LBA)';;
    cf) system='DR-DOS secured EXT DOS (LBA)';;
    d0) system='REAL/32 secure big partition';;
    da) system='Non-FS data / Powercopy Backup';;
    db) system='CP/M / CTOS / ...';;
    dd) system='Dell Media Direct';;
    de) system='Dell Utility';;
    df) system='BootIt';;
    e1) system='DOS access';;
    e3) system='DOS R/O';;
    e4) system='SpeedStor';;
    e8) system='LUKS';;
    eb) system='BeOS BFS';;
    ec) system='SkyOS';;
    ee) system='GPT';;
    ef) system='EFI (FAT-12/16/32)';;
    f0) system='Linux/PA-RISC boot';;
    f1) system='SpeedStor';;
    f2) system='DOS secondary';;
    f4) system='SpeedStor';;
    fb) system='VMware VMFS';;
    fc) system='VMware VMswap';;
    fd) system='Linux raid autodetect';;
    fe) system='LANstep';;
    ff) system='Xenix Bad Block Table';;
     *) system='Unknown';;
  esac

  echo "${system}";
}



## Function to convert GPT's Partition Type. ##
#
#   List from http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
#
#   ABCDEFGH-IJKL-MNOP-QRST-UVWXYZabcdef is stored as
#   GHEFCDAB-KLIJ-OPMN-QRST-UVWXYZabcdef (without the dashes)
#
#   For easy generation of the following list:
#    - Save list in a file "Partition_type_GUIDs.txt" in the folowing format: 
#
#	 Partition Type (OS) <TAB> GUID
#	 Partition Type (OS) <TAB> GUID
#	 Partition Type (OS) <TAB> GUID
#
#    - Then run the following:
#
#	 gawk -F '\t' '{ GUID=tolower($2); printf "    %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)  system=\"%s\";;\n", substr(GUID,7,1), substr(GUID,8,1), substr(GUID,5,1), substr(GUID,6,1), substr(GUID,3,1), substr(GUID,4,1), substr(GUID,1,1), substr(GUID,2,1), substr(GUID,12,1), substr(GUID,13,1), substr(GUID,10,1), substr(GUID,11,1), substr(GUID,17,1), substr(GUID,18,1), substr(GUID,15,1), substr(GUID,16,1), substr(GUID,20,4), substr(GUID,25,12), $1 } END { print "				   *)  system='-';" }' Partition_type_GUIDs.txt
#
#    - Some GUIDs are not unique for one OS. To find them, you can run:
#
#	 gawk -F "\t" '{print $2}' GUID_Partition_Table_list.txt | sort | uniq -d | grep -f - GUID_Partition_Table_list.txt
#
#		Basic data partition (Windows)	EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
#		Data partition (Linux)		EBD0A0A2-B9E5-4433-87C0-68B6B72699C7
#		ZFS (Mac OS X)			6A898CC3-1DD2-11B2-99A6-080020736631
#		/usr partition (Solaris)	6A898CC3-1DD2-11B2-99A6-080020736631
#

UUIDToSystem () {
  local type=$1 system;

  case ${type} in
    00000000000000000000000000000000)  system='Unused entry';;
    41ee4d02e733d3119d690008c781f39f)  system='MBR partition scheme';;
    28732ac11ff8d211ba4b00a0c93ec93b)  system='EFI System partition';;
    4861682149646f6e744e656564454649)  system='BIOS Boot partition';;
    dee2bfd3af3ddf11ba40e3a556d89593)  system="Intel Fast Flash (iFFS) partition (for Intel Rapid Start technology)";;

    ## GUIDs that are not unique for one OS ##
    a2a0d0ebe5b9334487c068b6b72699c7)  system='Data partition (Windows/Linux)';;
    c38c896ad21db21199a6080020736631)  system='ZFS (Mac OS X) or /usr partition (Solaris)';;
    
    ## Windows GUIDs ##
    16e3c9e35c0bb84d817df92df00215ae)  system='Microsoft Reserved Partition (Windows)';;
    # Same GUID as old GUID for "Basic data partition (Linux)"
  # a2a0d0ebe5b9334487c068b6b72699c7)  system='Basic data partition (Windows)';;
    aac808588f7ee04285d2e1e90434cfb3)  system='Logical Disk Manager (LDM) metadata partition (Windows)';;
    a0609baf3114624fbc683311714a69ad)  system='Logical Disk Manager (LDM) data partition (Windows)';;
    a4bb94ded106404da16abfd50179d6ac)  system='Windows Recovery Environment (Windows)';;
    90fcaf377def964e91c32d7ae055b174)  system='IBM General Parallel File System (GPFS) partition (Windows)';;

    ## HP-UX GUIDs ##
    1e4c8975eb3ad311b7c17b03a0000000)  system='Data partition (HP-UX)';;
    28e7a1e2e332d611a6827b03a0000000)  system='Service Partition (HP-UX)';;

    ## Linux GUIDs ##
    # Same GUID as "Basic data partition (Windows)" GUID
  # a2a0d0ebe5b9334487c068b6b72699c7)  system='Data partition (Linux)';;
    # New GUID to avoid that Linux partitions show up as unformatted partitions in Windows.
    af3dc60f838472478e793d69d8477de4)  system='Data partition (Linux)';;  
    0f889da1fc053b4da006743f0f84911e)  system='RAID partition (Linux)';;
    6dfd5706aba4c44384e50933c84b4f4f)  system='Swap partition (Linux)';;
    79d3d6e607f5c244a23c238f2a3df928)  system='Logical Volume Manager (LVM) partition (Linux)';;
    3933a68d0700c060c436083ac8230908)  system='Reserved (Linux)';;

    ## FreeBSD GUIDs ##
    9d6bbd83417fdc11be0b001560b84f0f)  system='Boot partition (FreeBSD)';;
    b47c6e51cf6ed6118ff800022d09712b)  system='Data partition (FreeBSD)';;
    b57c6e51cf6ed6118ff800022d09712b)  system='Swap partition (FreeBSD)';;
    b67c6e51cf6ed6118ff800022d09712b)  system='Unix File System (UFS) partition (FreeBSD)';;
    b87c6e51cf6ed6118ff800022d09712b)  system='Vinum volume manager partition (FreeBSD)';;
    ba7c6e51cf6ed6118ff800022d09712b)  system='ZFS partition (FreeBSD)';;

    ## Mac OS X GUIDs ##
    005346480000aa11aa1100306543ecac)  system='Hierarchical File System Plus (HFS+) partition (Mac OS X)';;
    005346550000aa11aa1100306543ecac)  system='Apple UFS (Mac OS X)';;
  # c38c896ad21db21199a6080020736631)  system='ZFS (Mac OS X)';;
    444941520000aa11aa1100306543ecac)  system='Apple RAID partition (Mac OS X)';;
    444941524f5faa11aa1100306543ecac)  system='Apple RAID partition offline (Mac OS X)';;
    746f6f420000aa11aa1100306543ecac)  system='Apple Boot partition (Mac OS X)';;
    6562614c006caa11aa1100306543ecac)  system='Apple Label (Mac OS X)';;
    6f6365526576aa11aa1100306543ecac)  system='Apple TV Recovery partition (Mac OS X)';;
    726f74536761aa11aa1100306543ecac)  system="Apple Core Storage (i.e. Lion FileVault) partition (Mac OS X)";;

    ## Solaris GUIDs ##
    45cb826ad21db21199a6080020736631)  system='Boot partition (Solaris)';;
    4dcf856ad21db21199a6080020736631)  system='Root partition (Solaris)';;
    6fc4876ad21db21199a6080020736631)  system='Swap partition (Solaris)';;
    2b648b6ad21db21199a6080020736631)  system='Backup partition (Solaris)';;
  # c38c896ad21db21199a6080020736631)  system='/usr partition (Solaris)';;
    e9f28e6ad21db21199a6080020736631)  system='/var partition (Solaris)';;
    39ba906ad21db21199a6080020736631)  system='/home partition (Solaris)';;
    a583926ad21db21199a6080020736631)  system='Alternate sector (Solaris)';;
    3b5a946ad21db21199a6080020736631)  system='Reserved partition (Solaris)';;
    d130966ad21db21199a6080020736631)  system='Reserved partition (Solaris)';;
    6707986ad21db21199a6080020736631)  system='Reserved partition (Solaris)';;
    7f23966ad21db21199a6080020736631)  system='Reserved partition (Solaris)';;
    c72a8d6ad21db21199a6080020736631)  system='Reserved partition (Solaris)';;

    ## NetBSD GUIDs ##
    328df4490eb1dc11b99b0019d1879648)  system='Swap partition (NetBSD)';;
    5a8df4490eb1dc11b99b0019d1879648)  system='FFS partition (NetBSD)';;
    828df4490eb1dc11b99b0019d1879648)  system='LFS partition (NetBSD)';;
    aa8df4490eb1dc11b99b0019d1879648)  system='RAID partition (NetBSD)';;
    c419b52d0fb1dc11b99b0019d1879648)  system='Concatenated partition (NetBSD)';;
    ec19b52d0fb1dc11b99b0019d1879648)  system='Encrypted partition (NetBSD)';;

    ## ChromeOS GUIDs ##
    5d2a3afe324fa741b725accc3285a309)  system="ChromeOS kernel";;
    02e2b83c7e3bdd478a3c7ff2a13cfcec)  system="ChromeOS rootfs";;
    3d750a2e489eb0438337b15192cb1b5e)  system="ChromeOS future use";;

    ## Haiku GUIDs ##
    31534642a33bf110802a4861696b7521)  system="Haiku BFS (Haiku)";;

    ## MidnightBSD GUIDs ##
    5ee4d5857c23e111b4b3e89a8f7fc3a7)  system="Boot partition (MidnightBSD) ";;
    5ae4d5857c23e111b4b3e89a8f7fc3a7)  system="Data partition (MidnightBSD)";;
    5be4d5857c23e111b4b3e89a8f7fc3a7)  system="Swap partition (MidnightBSD)";;
    8bef94037e23e111b4b3e89a8f7fc3a7)  system="Unix File System (UFS) partition (MidnightBSD)";;
    5ce4d5857c23e111b4b3e89a8f7fc3a7)  system="Vinum volume manager partition (MidnightBSD)";;
    5de4d5857c23e111b4b3e89a8f7fc3a7)  system="ZFS partition (MidnightBSD)";;

				   *)  system='-';
				       echo 'Unknown GPT Partiton Type' >> ${Unknown_MBR};
				       echo  ${type} >> ${Unknown_MBR};;   
  esac

  echo "${system}";
}



## Function which inserts a comma every third digit of a number. ##

InsertComma () {
  echo $1 | sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta';
}



## Function to read 4 bytes starting at $1 of device $2 and convert result to decimal. ##

Read4Bytes () {
  local start=$1 device=$2;

  echo $(hexdump -v -s ${start} -n 4 -e '4 "%u"' ${device});
}



## Function to read 8 bytes starting at $1 of device $2 and convert result to decimal. ##

Read8Bytes () {
  local start=$1 device=$2;
  local first4 second4;

  # Get ${first4} and ${second4} bytes at once.
  eval $(hexdump -v -s ${start} -n 8 -e '1/4 "first4=%u; " 1/4 "second4=%u"' ${device});

  echo $(( ${second4} * 4294967296 + ${first4} ));
}



## Functions to pretty print blkid output. ##

BlkidFormat='%-16s %-38s %-10s %s\n';

BlkidTag () {
  echo $(blkid -s $2 -o value $1 2>> ${Trash});
}



PrintBlkid () {
  local part=$1 suffix=$2;

  if [ x"$(blkid ${part} 2> ${Tmp_Log})" != x'' ] ; then
     printf "${BlkidFormat}" "${part}" "$(BlkidTag ${part} UUID)" "$(BlkidTag ${part} TYPE)" "$(BlkidTag ${part} LABEL)" >> ${BLKID}${suffix};
  else
     # blkid -p is not available on all systems.
     # This contructs makes sure the "usage" message is not displayed, but catches the "ambivalent" error.
     blkid -p "${part}" 2>&1 | grep "^${part}" >> ${BLKID}${suffix};
  fi
}


## Grub Legacy ##
#
#   Determine the embeded location of stage 2 in a stage 1 file,
#   look for the stage 2 and, if found, determine the
#   the location and the path of the embedded menu.lst.

stage2_loc () {
  local stage1="$1" HI;

  offset=$(hexdump -v -s 68 -n 4 -e '4 "%u"' "${stage1}");
  dr=$(hexdump -v -s 64 -n 1 -e '1/1 "%u"' "${stage1}");
  pa='T';
  Grub_Version='';

  for HI in ${!HDName[@]}; do
    hdd=${HDName[${HI}]};

    if [ ${offset} -lt  ${HDSize[HI]} ] ; then
       tmp=$(dd if=${hdd} skip=${offset} count=1 2>> ${Trash} | hexdump -v -n 4 -e '"%x"');

       if [[ "${tmp}" = '3be5652' || "${tmp}" = 'bf5e5652' ]] ; then
	  # stage2 files were found.
	  dd if=${hdd} skip=$((offset+1)) count=1 of=${Tmp_Log} 2>> ${Trash};
	  pa=$(hexdump -v -s 10 -n 1 -e '"%d"' ${Tmp_Log});
	  stage2_hdd=${hdd};
	  Grub_String=$(hexdump -v -s 18 -n 94 -e '"%_u"' ${Tmp_Log});
	  Grub_Version=$(echo ${Grub_String} | sed -e 's/nul[^$]*//');
	  BL=${BL}${Grub_Version};
	  menu=$(echo ${Grub_String} | sed -e 's/[^\/]*//' -e 's/nul[^$]*//');
	  menu=${menu%% *};
       fi
    fi
  done

  dr=$((${dr}-127));
  Stage2_Msg="looks at sector ${offset}";       

  if [ "${dr}" -eq 128 ] ; then
     Stage2_Msg="${Stage2_Msg} of the same hard drive";
  else
     Stage2_Msg="${Stage2_Msg} on boot drive #${dr}";
  fi

  Stage2_Msg="${Stage2_Msg} for the stage2 file";
                    
  if [ "${pa}" = "T" ] ; then
     # no stage 2 file found.
     Stage2_Msg="${Stage2_Msg}, but no stage2 files can be found at this location.";
  else
     pa=$((${pa}+1));
     Stage2_Msg="${Stage2_Msg}.  A stage2 file is at this location on ${stage2_hdd}.  Stage2 looks on";
                  
     if [ "${pa}" -eq 256 ] ; then
	Stage2_Msg="${Stage2_Msg} the same partition";
     else
	Stage2_Msg="${Stage2_Msg} partition #${pa}";
     fi

     Stage2_Msg="${Stage2_Msg} for ${menu}.";
  fi
}




## Grub2 ##
#
#   Collect fragments of core.img using information encoded in the first
#   block (diskboot.img).
#

grub2_read_blocklist () {
  local hdd="$1";
  local core_img_file="$2";

  local sector_nr_low sector_nr_high sector_nr fragment_size;
  local fragment_offset=1 block_list=500;

  # Assemble fragments from "hdd" passed to grub2_info.
  # Each block list entry is 12 bytes long and consists of
  #   8 bytes = fragment start absolute disk offset in sectors of 512 bytes
  #   2 bytes = fragment size in sectors of 512 bytes
  #   2 bytes = memory segment to load fragment into
  # Entries start at the end of the first sector of core.img and
  # go down. End marker is all zeroes.
  #
  # Blocklists were changed to 64 bit in 2006, so all versions BIS detects
  # should have it.
  #
  # Older versions of hexdump do not support 8 byte integers, so read
  # high and low words separately.
  
  while [ ${block_list} -gt 12 ] ; do
     sector_nr_low=$(hexdump -v -n 4 -s ${block_list} -e '1/4 "%u"' ${core_img_file});
     sector_nr_high=$(hexdump -v -n 4 -s $((block_list+4)) -e '1/4 "%u"' ${core_img_file});
     let "sector_nr = (sector_nr_high << 32) + sector_nr_low";
     if [ ${sector_nr} -eq 0 ] ; then
	return;
     fi

     fragment_size=$(hexdump -v -n 2 -s $((block_list+8)) -e '1/2 "%u"' ${core_img_file});

     dd if="${hdd}" of=${core_img_file} skip=${sector_nr} seek=${fragment_offset} count=${fragment_size} 2>> ${Trash} || return;
     let "fragment_offset += fragment_size";
     let "block_list -= 12";
  done
}

## Grub2 ##
#
#   Determine the embeded module name. This function implements manual
#   parsing of ELF information to avoid dependency on binutils or similar.
#

grub2_modname ()
{
  local modfile=$1;
  local file_size=$2;
  local e_ehsize sht_offset sht_entsize sht_num sht_shdrndx sht_strtab;
  local sht_strtabsize s_nameidx s_type s_name m_offset m_size;
  local i=0;

  # ELF header is at least 52 bytes in size
  if [ "${file_size}" -lt 52 ] ; then
    return;
  fi

  # ELF Magic + CLASS32 + LSB + VERSION
  if [ "$(hexdump -n 7 -e '4/1 "%02x" 3/1 "%x"' "${modfile}")" != '7f454c46111' ] ; then
    return;
  fi

  # RELOCATABLE + MACHINE + VERSION
  if [ "$(hexdump -s 16 -n 8 -e '2/2 "%x" 1/4 "%x"' "${modfile}")" != '131' ] ; then
    return;
  fi

  # ELF header size
  e_ehsize=$(hexdump -s 40 -n 2 -e '"%u"' "${modfile}")
  if [ "${e_ehsize}" -lt 52 -o "${e_ehsize}" -gt "${file_size}" ] ; then
    return;
  fi

  # Offset of section headers table
  sht_offset=$(hexdump -s 32 -n 4 -e '"%u"' "${modfile}")
  if [ "${sht_offset}" -lt "${e_ehsize}" -o "${sht_offset}" -ge "${file_size}" ] ; then
    return;
  fi

  # Size of section header
  sht_entsize=$(hexdump -s 46 -n 2 -e '"%u"' "${modfile}")

  # Number of section headers
  sht_num=$(hexdump -s 48 -n 2 -e '"%u"' "${modfile}")
  if [ "${sht_entsize}" -eq 0 -o "${sht_num}" -eq 0 -o $((sht_offset + sht_entsize*sht_num)) -gt "${file_size}" ] ; then
    return;
  fi

  # Index of section names string table
  sht_shdrndx=$(hexdump -s 50 -n 2 -e '"%u"' "${modfile}")
  if [ "${sht_shdrndx}" -ge "${sht_num}" ] ; then
    return;
  fi

  # Offset of section names string table
  sht_strtab=$(hexdump -s $((sht_offset + $((sht_shdrndx*sht_entsize)) + 16))  -n 4 -e '"%u"' "${modfile}");
  if [ "${sht_strtab}" -lt "${e_ehsize}" -o "${sht_strtab}" -ge "${file_size}" ] ; then
    return;
  fi

  # Size of section names string table
  sht_strtabsize=$(hexdump -s $((sht_offset + $((sht_shdrndx*sht_entsize)) + 20))  -n 4 -e '"%u"' "${modfile}");
  if [ "${sht_strtabsize}" -eq 0 -o "${sht_strtabsize}" -gt "$((file_size-sht_strtab))" ] ; then
    return;
  fi

  while [ "${i}" -lt $((sht_entsize*sht_num)) ] ; do
    s_nameidx=$(hexdump -s $((sht_offset + i))  -n 4 -e '"%u"' "${modfile}");
    if [ "${s_nameidx}" -lt "${sht_strtabsize}" ] ; then
      s_type=$(hexdump -s $((sht_offset + i + 4))  -n 4 -e '"%u"' "${modfile}");
      # PROGBITS
      if [ "${s_type}" -eq 1 ] ; then
	s_name=$(hexdump -s $((sht_strtab + s_nameidx))  -n "${sht_strtabsize}" -e "1/${sht_strtabsize} \"%s\"" "${modfile}");
	if [ "${s_name}" = '.modname' ] ; then
	  m_offset=$(hexdump -s $((sht_offset + i + 16))  -n 4 -e '"%u"' "${modfile}");
	  m_size=$(hexdump -s $((sht_offset + i + 20))  -n 4 -e '"%u"' "${modfile}");
	  if [ $((m_offset + m_size)) -lt "${file_size}" ] ; then
	    hexdump -s "${m_offset}"  -n "${m_size}" -e "/${m_size} \"%s\"" "${modfile}";
	    return
	  fi
	fi
      fi
    fi
    : $((i+=sht_entsize))
  done

  # Display "???" as indication that parsing failed
  printf '%s' '???'
  return
}

## Grub2 ##
#
#   Determine the (embeded) location of core.img for a Grub2 boot.img file,
#   determine the path of the grub2 directory and look for an embedded config file.
#

grub2_info () {
  local stage1="$1" hdd="$2";

  # When $grub2_version is "1.99-2.00", we want to override this value
  # with a more exact value later (needs to be a global variable).
  grub2_version="$3";

  # Have we got plain file or need to collect full core.img from blocklists?
  local core_source="$4";

  local sector_offset drive_offset directory_offset sector_nr drive_nr drive_nr_hex;
  local partition core_dir embedded_config HI magic core_img_found=0 embedded_config_found=0;
  local total_module_size kernel_image_size compressed_size offset_lzma lzma_uncompressed_size;
  local grub_module_info_offset grub_module_magic grub_modules_offset grub_modules_size;
  local grub_module_type grub_module_size grub_module_header_offset grub_modules_end_offset;
  local lzma_compressed_size reed_solomon_redundancy reed_solomon_length boot_dev boot_drive;
  local core_img_flavour='detect' modname all_modules need_core_prologue=0;
  local grub_module_header_next;

  > ${core_img_file_type_2}

  case "${grub2_version}" in
    1.96) sector_offset='68';  drive_offset='76'; directory_offset='553';;
    1.97-1.98) sector_offset='92';  drive_offset='100'; directory_offset='540';;
    1.99|1.99-2.00|2.00) sector_offset='92';  drive_offset='100';;
  esac

  # Offset to core.img (in sectors).
  sector_nr=$(hexdump -v -s ${sector_offset} -n 4 -e '4 "%u"' "${stage1}" 2>> ${Trash});

  # BIOS drive number on which grub2 looks for its second stage (=core.img):
  #   - "0xff" means that grub2 will use the BIOS drive number passed via the DL register.
  #   - if this value isn't "0xff", that value will used instead.
  # Since version 1.97 GRUB2 is using only 0xff. We cannot reliably determine BIOS numbers
  # anyway, so just skip core.img detection in this case.
  drive_nr_hex=$(hexdump -v -s ${drive_offset} -n 1 -e '"0x%02x"' "${stage1}" 2>> ${Trash});
  drive_nr=$(( ${drive_nr_hex} - 127 ));

  if [ "${drive_nr_hex}" != '0xff' ] ; then
    Grub2_Msg="is configured to load core.img from BIOS drive ${drive_nr} (${drive_nr_hex}) instead of using the boot drive passed by the BIOS";
    return
  fi

  Grub2_Msg="looks at sector ${sector_nr} of the same hard drive for core.img";


  for HI in ${!HDName[@]} ; do
    # If the drive name passed to grub2_info matches the drive name of the current
    # value of HDName, see if the sector offset to core.img is smaller than the
    # total number of sectors of that drive.

    if [ ${hdd} = ${HDName[${HI}]} ] ; then
       if [ ${sector_nr} -lt ${HDSize[HI]} ] ; then

	  if [ "${core_source}" = 'file' ] ; then
	     # Use "file" passed to grub2_info directly.
	     dd if="${stage1}" of=${core_img_file} skip=${sector_nr} count=1024 2>> ${Trash};
	  else
	     # Use "hdd" passed to grub2_info.
	     # First make sure to collect core.img fragments. Read the first block of
	     # core.img and assemble it further from blocklists
	     dd if="${hdd}" of=${core_img_file} skip=${sector_nr} count=1 2>> ${Trash};
	     grub2_read_blocklist "${hdd}" ${core_img_file};
	  fi

	  magic=$(hexdump -v -n 4 -e '/1 "%02x"' ${core_img_file});

	  # 5256be1b - upstream diskboot.S
	  # 5256be6f - unknown
	  # 52e82801 - Ubuntu diskboot.S with conditional message
	  # 52bff481 - RHEL7 diskboot.S with patched out message
	  # 5256be63 - trustedgrub2 1.4
	  # 5256be56 - diskboot.S with mjg TPM patches (e.g. in openSUSE Tumbleweed)

	  case "${magic}" in
	     '5256be1b'|'5256be6f'|'52e82801'|'52bff481'|'5256be63'|'5256be56')
	        core_img_found=1;;
	  esac

	  if [ ${core_img_found} -eq 1 ] ; then

	     if ( [ "${grub2_version}" = '1.99' ] || [ "${grub2_version}" = '1.99-2.00' ] || [ "${grub2_version}" = '2.00' ] ) ; then
		# Find the last 8 bytes of lzma_decode to find the offset of the lzma_stream:
		#   - v1.99: "d1 e9 df fe ff ff 00 00"
		#   - v2.00: "d1 e9 df fe ff ff 66 90" (pad bytes NOP)
		#            "d1 e9 df fe ff ff 8d"    (pad bytes LEA ...)
		#
		# arvidjaar@gmail.com:
		#   final directive in startup_raw.S is .p2align 4 which
		#   (at least using current GCC/GAS) adds lea instructions
		#   (8d...). Exact format and length apparently depend on pad
		#   size and may be on toolkit version. So just accept anything
		#   starting with lea.
		#
		# FIXME what if it ends on exact 16 byte boundary?

		eval $(hexdump -v -n 10000 -e '1/1 "%02x"' ${core_img_file} | \
		     ${AWK} '{ found_at=match($0, "d1e9dffeffff" ); if (found_at == "0") { print "offset_lzma=0" } \
			    else { print "offset_lzma=" ((found_at - 1 ) / 2 ) + 8 "; lzma_decode_last8bytes=" substr($0,found_at,16) ";" } }');

		if [ "${grub2_version}" = '1.99-2.00' ] ; then
		   if ( [ "${lzma_decode_last8bytes}" = "d1e9dffeffff6690" ] || [ "${lzma_decode_last8bytes:0:14}" = "d1e9dffeffff8d" ] ) ; then
		      grub2_version='2.00';
		   else
		      grub2_version='1.99';
		   fi
		fi
	     else
		# Grub2 (v1.96 and v1.97-1.98).
		partition=$(hexdump -v -s 532 -n 1 -e '"%d"' ${core_img_file});
		core_dir=$(hexdump -v -s ${directory_offset} -n 64 -e '"%_u"' ${core_img_file} | sed 's/nul[^$]*//');
	     fi

	     if [ "${grub2_version}" = '1.99' ] ; then

		# For Grub2 (v1.99), the core_dir is just at the beginning of the compressed part of core.img.
		
		# Get grub_total_module_size	: byte 0x208-0x20b of embedded core.img ==> byte 520
		# Get grub_kernel_image_size	: byte 0x20c-0x20f of embedded core.img ==> byte 524
		# Get grub_compressed_size	: byte 0x210-0x213 of embedded core.img ==> byte 528
		# Get grub_install_dos_part	: byte 0x214-0x218 of embedded core.img ==> byte 532 --> only 1 byte needed (partition)

		eval $(hexdump -v -s 520 -n 13 -e '1/4 "total_module_size=%u; " 1/4 "kernel_image_size=%u; " 1/4 "compressed_size=%u; " 1 "partition=%d;"' ${core_img_file});



		# Do we have xz or lzma installed?
		if [ "${UNLZMA}" != 'none' ] ; then
		   if [ ${offset_lzma} -ne 0 ] ; then

		      # Correct the offset to the lzma stream, when 8 subsequent bytes of zeros are at the start of this offset.
		      if [ $(hexdump -v -s ${offset_lzma} -n 8 -e '1/1 "%02x"'  ${core_img_file}) = '0000000000000000' ] ; then
			 offset_lzma=$(( ${offset_lzma} + 8 ));
		      fi

		      # Calculate the uncompressed size to which the compressed lzma stream needs to be expanded. 
		      lzma_uncompressed_size=$(( ${total_module_size} + ${kernel_image_size} - ${offset_lzma} + 512 ));

		      # Make lzma header (13 bytes): ${lzma_uncompressed_size} must be displayed in little endian format.
		      printf '\x5d\x00\x00\x01\x00'$( printf '%08x' $((${lzma_uncompressed_size} - ${offset_lzma} + 512 )) \
			 | ${AWK} '{printf "\\x%s\\x%s\\x%s\\x%s", substr($0,7,2), substr($0,5,2), substr($0,3,2), substr($0,1,2)}' )'\x00\x00\x00\x00' > ${Tmp_Log};

		      # Get lzma_stream, add it after the lzma header and decompress it.
		      dd if=${core_img_file} bs=${offset_lzma} skip=1 count=$((${lzma_uncompressed_size} / ${offset_lzma} + 1)) 2>> ${Trash} \
			 | cat ${Tmp_Log} - | ${UNLZMA} 2>> ${Trash} > ${core_img_file_unlzma};

		      # Get core dir.
		      core_dir=$( hexdump -v -n 64 -e '"%_c"' ${core_img_file_unlzma} );
		      # Remove "\0"s at the end.
		      core_dir="${core_dir%%\\0*}";


		      # Offset of the grub_module_info structure in the uncompressed part.
		      grub_module_info_offset=$(( ${kernel_image_size} - ${offset_lzma} + 512 ));

		      eval $(hexdump -v -n 12 -s ${grub_module_info_offset} -e '"grub_module_magic=" 4/1 "%_c" 1/4 "; grub_modules_offset=%u; " 1/4 "grub_modules_size=%u;"' ${core_img_file_unlzma});

		      # Check for the existence of the grub_module_magic.
		      if [ x"${grub_module_magic}" = x'mimg' ] ; then
			 # Embedded grub modules found.
			 grub_modules_end_offset=$(( ${grub_module_info_offset} + ${grub_modules_size} ));
			 grub_module_header_offset=$(( ${grub_module_info_offset} + ${grub_modules_offset} ));

			 # Traverse through the list of modules and check if it is a config module.
			 while [ ${grub_module_header_offset} -lt ${grub_modules_end_offset} ] ; do

			   eval $(hexdump -v -n 8 -s ${grub_module_header_offset} -e '1/4 "grub_module_type=%u; " 1/4 "grub_module_size=%u;"' ${core_img_file_unlzma});

			   if [ ${grub_module_type} -eq 2 ] ; then
			      # This module is an embedded config file.
			      embedded_config_found=1;

			      embedded_config=$( hexdump -v -n $(( ${grub_module_size} - 8 )) -s $(( ${grub_module_header_offset} + 8 )) -e '"%_c"' ${core_img_file_unlzma} );
			      # Remove "\0" at the end.
			      embedded_config=$( printf "${embedded_config%\\0}" );

			      break;
			   fi

			   grub_module_header_offset=$(( ${grub_module_header_offset} + ${grub_module_size} ));

			 done
		     fi		      
		   fi
		else
		   # When xz or lzma isn't available, we can't get the core_dir, but we still can show some info.
		   core_dir='??';

		   echo 'To be able to see for which directory Grub2 (v1.99) looks for, install "xz" or "lzma".' >&2;
		fi
	     elif [ "${grub2_version}" = '2.00' ] ; then

		# For Grub2 (v2.00), the core_dir is stored in the compressed part of core.img in the same
		# way as the modules and embedded config file.
		
		# Get grub_compressed_size	   : byte 0x208-0x20b of embedded core.img ==> byte 520
		# Get grub_uncompressed_size	   : byte 0x20c-0x20f of embedded core.img ==> byte 524
		# Get grub_reed_solomon_redundancy : byte 0x210-0x213 of embedded core.img ==> byte 528
		# Get grub_no_reed_solomon_length  : byte 0x214-0x217 of embedded core.img ==> byte 532
		# Get grub_boot_dev		   : byte 0x218-0x21a of embedded core.img ==> byte 536 ( should also contain the grub_boot_drive field )
		# Get grub_boot_drive		   : byte 0x21b of embedded core.img ==> byte 539

		eval $(hexdump -v -s 520 -n 20 -e '1/4 "lzma_compressed_size=%u; " 1/4 "lzma_uncompressed_size=%u; " 1/4 "reed_solomon_redundancy=%u; " 1/4 "reed_solomon_length=%u; boot_dev=" 3/1 "%x" 1 "; boot_drive=%d;"' ${core_img_file});



		# Do we have xz or lzma installed?
		if [ "${UNLZMA}" != 'none' ] ; then
		   if [ ${offset_lzma} -ne 0 ] ; then

		      # Grub2 pads the start of the lzma stream to a 16 bytes boundary.
		      # Correct the offset to the lzma stream if necessary
		      # Current GCC adds lea instructions as pad bytes
		      padsize=$(( (((${offset_lzma} + 15) >> 4) << 4) - ${offset_lzma} )); 
		      if ( [ ${padsize} -gt 0 ] ) ; then 
			 offset_lzma=$(( ${offset_lzma} + ${padsize} )); 
		      fi


		      # Make lzma header (13 bytes): ${lzma_uncompressed_size} must be displayed in little endian format.
		      printf '\x5d\x00\x00\x01\x00'$( printf '%08x' ${lzma_uncompressed_size} \
			 | ${AWK} '{printf "\\x%s\\x%s\\x%s\\x%s", substr($0,7,2), substr($0,5,2), substr($0,3,2), substr($0,1,2)}' )'\x00\x00\x00\x00' > ${Tmp_Log};


		      # Get lzma_stream, add it after the lzma header and decompress it.
		      dd if=${core_img_file} bs=${offset_lzma} skip=1 count=${lzma_compressed_size} 2>> ${Trash} \
			 | cat ${Tmp_Log} - | ${UNLZMA} 2>> ${Trash} > ${core_img_file_unlzma};


		      # Get offset to the grub_module_info structure in the uncompressed part.
		      eval $(hexdump -v -s 19 -n 4 -e '1/4 "grub_module_info_offset=%u;"' ${core_img_file_unlzma});

		      eval $(hexdump -v -n 12 -s ${grub_module_info_offset} -e '"grub_module_magic=" 4/1 "%_c" 1/4 "; grub_modules_offset=%u; " 1/4 "grub_modules_size=%u;"' ${core_img_file_unlzma});

		      # Check for the existence of the grub_module_magic.
		      if [ x"${grub_module_magic}" = x'mimg' ] ; then
			 # Embedded grub modules found.
			 grub_modules_end_offset=$(( ${grub_module_info_offset} + ${grub_modules_size} ));
			 grub_module_header_offset=$(( ${grub_module_info_offset} + ${grub_modules_offset} ));

			 # Traverse through the list of modules and check if it is a config module.
			 # Upstream GRUB2 supports following module types:
			 #   0 - ELF modules; may be included multiple times
			 #   1 - memory disk image; should be included just once
			 #   2 - embedded initial configuration code; should be included just once
			 #   3 - initial value of ${prefix} variable. Device part may be omitted,
			 #       in which case device is guessed at startup
			 #   4 - public GPG keyring used for file signature checking;
			 #       may be included multiple times
			 #
			 # All parts are optional (although in practice
			 # at least drivers for disk and filesystem must be
			 # present).
			 #
			 # Since RPM version 2.00-10 fedora includes patch that
			 # inserts additional module type after the first one,
			 # thus shifting all numbers starting with 1. So
			 # embedded config and prefix become 3 and 4 on fedora.
			 while [ ${grub_module_header_offset} -lt ${grub_modules_end_offset} ] ; do

			   if [ $(( ${grub_modules_end_offset} - ${grub_module_header_offset} )) -lt 8 ] ; then
			      echo 'Remaining space in GRUB2 module list too short for a module' >&2;
			      all_modules="${all_modules} <short>";
			      need_core_prologue=1;
			      break
			   fi

			   eval $( hexdump -v -n 8 -s ${grub_module_header_offset} -e '1/4 "grub_module_type=%u; " 1/4 "grub_module_size=%u;"' ${core_img_file_unlzma} );
			   # Next module is always aligned on 4 bytes boundary on i386,
			   # but sometimes grub stores shorter size. Make sure to adjust it.
			   grub_module_header_next=$(( ${grub_module_header_offset} + 8 + (((${grub_module_size} - 8 + 3) >> 2) << 2) ));

			   if [ ${grub_module_header_next} -gt ${grub_modules_end_offset} ] ; then
			      printf 'GRUB2 module size too large; skipping remaining modules. Size left: %d\n' $(( {grub_modules_end_offset} - ${grub_module_header_offset} )) >&2;
			      all_modules="${all_modules} <skipped>";
			      need_core_prologue=1;
			      break
			   fi

			   if [ ${grub_module_type} -eq 0 ] ; then
			      # Regular ELF module
			      dd count=$(( grub_module_size - 8 )) skip=$(( grub_module_header_offset + 8 )) if=${core_img_file_unlzma} of=${GRUB200_Module} bs=1 2>> ${Trash};
			      modname=$(grub2_modname ${GRUB200_Module} $(( grub_module_size - 8 )));
			      if [ -n "${modname}" ] ; then
			        all_modules="${all_modules} ${modname}";
				need_core_prologue=1;
			      fi
			   elif [ ${grub_module_type} -eq 1 ] ; then
			      # "stale" ELF module on fedora or memory disk everywhere else
			      if [ ${core_img_flavour} = 'detect' ] ; then
				 if [ "$(hexdump -v -n 4 -s $((grub_module_header_offset+8)) -e '"%c"' ${core_img_file_unlzma})" = $'\x7f''ELF' ] ; then
				    # fedora "stale" ELF module
				    # TODO display Fedora stale modules
				    core_img_flavour='fedora';
				 else
				    core_img_flavour='upstream';
				 fi
			      fi

			   elif [ ${grub_module_type} -eq 2 ] ; then
			      # memory disk on fedora or embedded config everywhere else
			      if [ ${core_img_flavour} = 'detect' ] ; then
			         # Normally core.img will have prefix which is easier to detect,
			         # so leave detection as last resort.
			         dd if=${core_img_file_unlzma} of=${core_img_file_type_2} bs=1 skip=$((grub_module_header_offset+8)) count=$((grub_module_size-8)) 2>> ${Trash};
			      fi
			      if [ ${core_img_flavour} = 'upstream' ] ; then
				 # This module is an embedded config file.
				 embedded_config_found=1;
				 need_core_prologue=1;

				 # Remove padding starting with the first "\0" at the end.
				 embedded_config=$( hexdump -v -n $(( ${grub_module_size} - 8 )) -s $(( ${grub_module_header_offset} + 8 )) -e '"%_c"' ${core_img_file_unlzma} | sed -e 's/\(\\0\).*$//');
			      fi

			   elif [ ${grub_module_type} -eq 3 ] ; then
			      # embedded config on fedora or prefix everywhere else
			      if [ ${core_img_flavour} = 'detect' ] ; then
				 # if it looks like file name, assume prefix
				 if [[ "$(hexdump -v -n 1 -s $(( grub_module_header_offset + 8 )) -e '"%c"' ${core_img_file_unlzma})" == [/\(] ]] ; then
				    core_img_flavour='upstream';
				 else
				    core_img_flavour='fedora';
				 fi
			      fi
			      if [ ${core_img_flavour} = 'upstream' ] ; then
				 # This module contains the prefix.

				 # Get core dir.
				 # Remove padding "\0"'s at the end.
				 core_dir=$( hexdump -v -n $(( ${grub_module_size} - 8 )) -s $(( ${grub_module_header_offset} + 8 )) -e '"%_c"' ${core_img_file_unlzma} | sed -e 's/\(\\0\)\+$//');
			      elif [ ${core_img_flavour} = 'fedora' ] ; then
				 # This module is an embedded config file.
				 embedded_config_found=1;
				 need_core_prologue=1;

				 # Remove padding starting with the first "\0" at the end.
				 embedded_config=$( hexdump -v -n $(( ${grub_module_size} - 8 )) -s $(( ${grub_module_header_offset} + 8 )) -e '"%_c"' ${core_img_file_unlzma} | sed -e 's/\(\\0\).*$//');
			      fi

			   elif [ ${grub_module_type} -eq 4 ] ; then
			      # prefix on fedora or GPG keyring everywhere else
			      if [ ${core_img_flavour} = 'detect' ] ; then
				 # if it looks like file name, assume prefix
			         # GPG ring normall has \x99 as first byte
				 if [[ "$(hexdump -v -n 1 -s $(( grub_module_header_offset + 8 )) -e '"%c"' ${core_img_file_unlzma})" == [/\(] ]] ; then
				    core_img_flavour='fedora';
				 else
				    core_img_flavour='upstream';
				 fi
			      fi
			      if [ ${core_img_flavour} = 'fedora' ] ; then
				 # This module contains the prefix.

				 # Get core dir.
				 # Remove padding "\0"'s at the end.
				 core_dir=$( hexdump -v -n $(( ${grub_module_size} - 8 )) -s $(( ${grub_module_header_offset} + 8 )) -e '"%_c"' ${core_img_file_unlzma} | sed -e 's/\(\\0\)\+$//');
			      elif [ ${core_img_flavour} = 'upstream' ] ; then
				 # TODO list GPG keyring
				 :
			      fi
			   fi

			   grub_module_header_offset=${grub_module_header_next};

			 done
		      fi	      
		   fi
		else
		   # When xz or lzma isn't available, we can't get the core_dir, but we still can show some info.
		   core_dir='??';

		   echo 'To be able to see for which directory Grub2 (v2.00) looks for, install "xz" or "lzma".' >&2;
		fi
	     fi
	  fi
       fi
    fi
  done

  if [ "${grub2_version}" = '2.00' ] ; then
     if [ -s ${core_img_file_type_2} ] ; then
	if [ "${core_img_flavour}" = 'detect' ] ; then
	   # Neither type 1, 3 or 4 modules were present. So we have either
	   # embedded config or memory disk. 
	   if type file > /dev/null 2>&1 ; then
	      if [[ "$(LC_ALL=C file ${core_img_file_type_2})" == *"ASCII text"* ]] ; then
		 # upstream embedded config
		 core_img_flavour='upstream';
	      fi
	   fi
	fi
	if [ ${core_img_flavour} = 'upstream' ] ; then
	   embedded_config_found=1;
	   need_core_prologue=1;

	   # Remove padding starting with the first "\0" at the end.
	   embedded_config=$( hexdump -v -e '"%_c"' ${core_img_file_type_2} | sed -e 's/\(\\0\).*$//' );
	fi
     fi
  fi


  if [ ${core_img_found} -eq 0 ] ; then
     # core.img not found.
     Grub2_Msg="${Grub2_Msg}, but core.img can not be found at this location";
  else
     # core.img found.

     Grub2_Msg="${Grub2_Msg}. core.img is at this location";

     # In GRUB 2.00 core.img prefix is optional
     if [ -n "${core_dir}" ]; then
	Grub2_Msg="${Grub2_Msg} and looks for ${core_dir}";

	if [ -n "${partition}" ]; then
	   partition=$(( ${partition} + 1 ));
	   if [ ${partition} -eq 255 ] ; then
	      Grub2_Msg="${Grub2_Msg} on this drive";
	   else
	      Grub2_Msg="${Grub2_Msg} in partition ${partition}";
	   fi
	fi
     fi

     if [ ${need_core_prologue} -eq 1 ] ; then
	Grub2_Msg=$(printf "${Grub2_Msg}. It also embeds following components:");
     fi

     if [ -n "${all_modules}" ] ; then

	all_modules="${all_modules# }";
	Grub2_Msg=$(printf "${Grub2_Msg}\n\nmodules\n--------------------------------------------------------------------------------\n${all_modules}\n--------------------------------------------------------------------------------");

     fi

     if [ ${embedded_config_found} -eq 1 ] ; then
	# Embedded config file found.

	Grub2_Msg=$(printf "${Grub2_Msg}\n\nconfig script\n--------------------------------------------------------------------------------\n${embedded_config}\n--------------------------------------------------------------------------------");

     fi
  fi
}



## Get embedded menu for grub4dos (grldr/grub.exe) and wee (installed in the MBR). ##
#
#   Function arguments:
#
#   - arg 1:  source     = file (grub4dos) / device (WEE)
#   - arg 2:  titlename  = first part of the title that needs to be displayed
#

get_embedded_menu () {
  local source=$1 titlename=$2;

  # Check if magic bytes that go before the embedded menu, are present.
  offset_menu=$(dd if="${source}" count=4 bs=128k 2>> ${Trash} | hexdump -v -e '/1 "%02x"' | grep -b -o 'b0021ace000000000000000000000000');

  if [ -n "${offset_menu}" ] ; then
     # Magic found.
     titlebar_gen "${titlename}" " embedded menu";
     echo '--------------------------------------------------------------------------------' >> "${Log1}";

     # Calcutate the exact offset to the embedded menu.
     offset_menu=$(( ( ${offset_menu%:*} / 2 ) + 16 ));
	 dd if="${source}" count=1 skip=1 bs=${offset_menu} 2>> ${Trash} | ${AWK} 'BEGIN { RS="\0" } { if (NR == 1) print $0 }' >> "${Log1}";

     echo '--------------------------------------------------------------------------------' >> "${Log1}";
  fi
}



## Show the location (offset) of a file on a disk ##
#
#   Function arguments:
#
#   - arg 1:  filename1
#   - arg 2:  filename2
#   - arg 3:  filename3
#   - ......
#
#   Return values:
#
#   - 0:  None of the provided filenames was found.
#   - 1:  At least one of the provided filenames was found.

last_block_of_file () {
  local display='0';
  local BlockSize Fragments Filefrag_Format EndGiByte EndGByte;

  # Remove an existing ${Tmp_Log} log.
  rm -f ${Tmp_Log};

  # "$@" contains all function arguments (filenames).
  for file in "$@" ; do
    if [[ -f "${file}" ]] && [[ -s "${file}" ]] && FileNotMounted "${mountname}/${file}" "${mountname}" ; then

       # There are 4 versions of e2fsprogs filefrag output.
       # In all cases final line could be "1 extent" instead.
       #
       # v1
       #  Blocksize of file %s is %d
       #  File size of %s is %lld (%d blocks)
       #  %s: %d extents found[, perfection would be %d extent%s]
       #
       # v2
       #  Blocksize of file %s is %d
       #  File size of %s is %lld (%d blocks)
       #  First block: %ld
       #  Last block: %ld
       #  %s: %d extents found[, perfection would be %d extent%s]
       #
       # v3
       #  File size of %s is %lld (%ld block%s, blocksize %d)
       #   ext logical physical expected length flags
       #     0     nnn      nnn             nnn xxx
       #     1     nnn      nnn      nnn    nnn xxx
       #   ...
       #  %s: %d extents found[, perfection would be %d extent%s]
       #
       # v4
       #  File size of %s is %llu (%lu block%s of %d bytes)
       #   ext: logical_offset: physical_offset: length: expected: flags:
       #     0:    nnn..   nnn:     nnn..   nnn:    nnn:           xxx
       #     1:    nnn..   nnn:     nnn..   nnn:    nnn:      nnn: xxx
       #   ...
       #  %s: %d extents found[, perfection would be %d extent%s]
       #
       # FIXME e2fsprogs filefrag output "Last block:", not "Last Block:".
       #       Was there yet another filefrag implementation?
       #
       # XXX Original code metioned filefrag output that can show last
       #     block but not number of extents. Unless there was some other
       #     implementation of filefrag, it does not match e2fsprogs sources.
       #
       # XXX Can we hit files with spaces (field count is wrong then)?

       eval $(filefrag -v "${file}" \
	     | ${AWK} -F ' ' 'BEGIN { blocksize=0; expected=0; extents=0; ext_ind=0; last_ext_loc=0; ext_length=0; filefrag_format=""; last_block=0 } \
		{ if ( $1 == "Blocksize" ) { blocksize=$6; filefrag_format="v1"; }; \
		if ( filefrag_format == "v1" ) { \
			if ( $1$2 ~ "LastBlock:" ) { last_block = $3 }; \
		} else if ( $(NF-1) == "blocksize" ) { \
		  blocksize = substr($NF,0,length($NF) - 1); \
		  filefrag_format = "v3"; \
		} else if ( $(NF) == "bytes)" ) { \
		  blocksize = $(NF-1); \
		  filefrag_format = "v4"; \
		  FS=" *|: *|[.][.] *"; \
		} \
		if ( expected != 0 ) { \
		   if ( filefrag_format == "v3" && ext_ind == $1 ) { \
		     if ( last_ext_loc < $3 ) { \
			last_ext_loc = $3; \
			if ( substr($0, expected, 1) == " " ) { \
			   ext_length = $4; } \
			else { \
			   ext_length = $5; \
			} \
		      } \
		   } else if ( filefrag_format == "v4" && ext_ind == $2 ) { \
		    if ( last_block < $6 ) { \
		      last_block = $6; \
		    } \
		   } \
		   ext_ind += 1; \
		} else { \
		  if ( filefrag_format == "v3" && $4 == "expected" ) { \
		     expected= index($0,"expected") + 7; \
		  } else if ( filefrag_format == "v4" && $2 == "ext" ) { \
		    expected = 1; \
		  } \
		} \
		if ( $3 == "extents" ) { \
		  extents = $2; \
		} else if ( $3 == "extent" ) { \
		  extents = 1; \
		} \
		} \
	       	END { \
			if ( filefrag_format == "v3" ) { \
				last_block = last_ext_loc + ext_length; \
			} \
			printf "BlockSize=" blocksize "; Fragments=" extents "; Filefrag_Format=" filefrag_format "; "; \
			if ( last_block == 0 ) { \
				printf "EndGiByte=??; EndGByte=??;" \
			} else { \
				EndByte = last_block * blocksize + 512 * '${start}'; \
				printf "EndGiByte=%.9f; EndGByte=%.9f;", EndByte / 1024 ^ 3, EndByte / 1000 ^ 3; \
			} \
		}');

       if [ "${Filefrag_Format}" = '' ] ; then
	  echo "Unknown filefrag output format" >&2;
	  return 0;
       fi

       if [ "${BlockSize}" -ne 0 ] ; then
	  if [ "${Fragments}" -eq 0 ] ; then
	     printf "%14s = %-14s %s\n" "${EndGiByte}" "${EndGByte}" "${file}" >> ${Tmp_Log};
	  else
	     printf "%14s = %-14s %-45s %2s\n" "${EndGiByte}" "${EndGByte}" "${file}" "${Fragments}" >> ${Tmp_Log};
	  fi
       fi

       # Return 1, when we find at least one of the provided filenames,
       # so we know that we need to display the content of ${Tmp_Log} later.
       display=1;
    fi
  done

  return ${display};
}



## "titlebar_gen" generates the ${name}${file} title bar to always be 80 characters in length. ##

titlebar_gen () {
  local name_file name_file_length equal_signs_line_length equal_signs_line;
  
  name_file="${1}${2}:";
  name_file_length=${#name_file};

  equal_signs_line_length=$(((80-${name_file_length})/2-1));

  # Build "===" string.
  printf -v equal_signs_line "%${equal_signs_line_length}s";
  printf -v equal_signs_line "%s" "${equal_signs_line// /=}";

  if [ "$((${name_file_length}%2))" -eq 1 ]; then
     # If ${name_file_length} is odd, add an extra "=" at the end.
     printf "\n%s %s %s=\n\n" "${equal_signs_line}" "${name_file}" "${equal_signs_line}" >> "${Log1}";
  else
     printf "\n%s %s %s\n\n" "${equal_signs_line}" "${name_file}" "${equal_signs_line}" >> "${Log1}";
  fi
}



## Start ##



# Center title.
BIS_title=$(printf 'Boot Info Script %s      [%s]' "${VERSION}" "${RELEASE_DATE}");
printf -v BIS_title_space "%$(( ( 80 - ${#BIS_title} ) / 2 - 1 ))s";
printf "${BIS_title_space}${BIS_title}\n" > "${Log}";

if [ ! -z "${LAST_GIT_COMMIT_SHORTLOG}" ] ; then
   printf '\nLast git commit:       %s\nCommit date:           %s\n' \
          "${LAST_GIT_COMMIT_SHORTLOG}" "${LAST_GIT_COMMIT_DATE}" >> "${Log}";
fi

printf '\n\n============================= Boot Info Summary: ===============================\n\n' >> "${Log}";



# Search for hard drives which don't exist, have a corrupted partition table
# or don't have a parition table (whole drive is a filesystem).
# Information on all hard drives which a valid partition table are stored in 
# the hard drives arrays: HD?????

# id for Filesystem Drives.
FSD=0;

# Clear blkid cache
blkid -g;

for drive in ${All_Hard_Drives} ; do
  size=$(fdisks ${drive});

  PrintBlkid ${drive};

  if [ 0 -lt ${size} 2>> ${Trash} ] ; then
     if [ x"$(blkid  ${drive})" = x'' ] || [ x"$(blkid  | grep ${drive}:)" = x'' ] ; then
	# Drive is not a filesytem.

	size=$((2*size));

	HDName[${HI}]=${drive};
	HDSize[${HI}]=${size};

	# Get and set HDHead[${HI}], HDTrack[${HI}] and HDCylinder[${HI}] all at once.
	eval $(fdisk -lu ${drive} 2>> ${Trash} | ${AWK} -F ' ' '$2 ~ "head" { print "HDHead['${HI}']=" $1 "; HDTrack['${HI}']=" $3 "; HDCylinder['${HI}']=" $5 }' );

	# Look at the first 4 bytes of the second sector to identify the partition table type.
	case $(hexdump -v -s 512 -n 4 -e '"%_u"' ${drive}) in
	  'EMBR') HDPT[${HI}]='BootIt';;
	  'EFI ') HDPT[${HI}]='EFI';;
	       *) HDPT[${HI}]='MSDos';;
	esac

	HI=$((${HI}+1));
     else
        # Drive is a filesystem.

        if [ $( expr match "$(BlkidTag "${drive}" TYPE)" '.*raid') -eq 0 ] || [ x"$(BlkidTag "${drive}" UUID)" != x'' ] ; then
	   FilesystemDrives[${FSD}]="${drive}";
	   ((FSD++));
	fi
     fi
  else
     printf "$(basename ${drive}) " >> ${FakeHardDrives};
  fi
done



## Identify the MBR of each hard drive. ##
echo 'Identifying MBRs...';

for HI in ${!HDName[@]} ; do 
  drive="${HDName[${HI}]}";
  Message="is installed in the MBR of ${drive}";

  # Read the whole MBR in hexadecimal format.
  MBR_512=$(hexdump -v -n 512 -e '/1 "%02x"' ${drive});

  ## Look at the first 2,3,4 or 8 bytes of the hard drive to identify the boot code installed in the MBR. ##
  #
  #   If it is not enough, look at more bytes.

  MBR_sig2="${MBR_512:0:4}";
  MBR_sig3="${MBR_512:0:6}";
  MBR_sig4="${MBR_512:0:8}";
  MBR_sig8="${MBR_512:0:16}";

  ## Bytes 0x80-0x81 of the MBR. ##
  #
  #   Use it to differentiate between different versions of the same bootloader.

  MBR_bytes80to81="${MBR_512:256:4}";


  BL=;
  case ${MBR_sig2} in

    eb48) ## Grub Legacy is in the MBR. ##
	  BL="Grub Legacy";

	  # 0x44 contains the offset to the next stage.
	  offset=$(hexdump -v -s 68 -n 4 -e '"%u"' ${drive});

	  if [ "${offset}" -ne 1 ] ; then
	     # Grub Legacy is installed without stage1.5 files.
	     stage2_loc ${drive};
	     Message="${Message} and ${Stage2_Msg}";
	  else
	     # Grub is installed with stage1.5 files.
	     Grub_String=$(hexdump -v -s 1042 -n 94 -e '"%_u"' ${drive});
	     Grub_Version="${Grub_String%%nul*}";

	     BL="Grub Legacy (v${Grub_Version})";

	     tmp="/${Grub_String#*/}";
	     tmp="${tmp%%nul*}";

	     eval $(echo ${tmp} | ${AWK} '{ print "stage=" $1 "; menu=" $2 }');

	     [[ x"$menu" = x'' ]] || stage="${stage} and ${menu}";

	     part_info=$((1045 + ${#Grub_Version}));
	     eval $(hexdump -v -s ${part_info} -n 2 -e '1/1 "pa=%u; " 1/1 "dr=%u"' ${drive});
	     
	     dr=$(( ${dr} - 127 ));
	     pa=$(( ${pa} + 1 ));

	     if [ "${dr}" -eq 128 ] ; then
		Message="${Message} and looks on the same drive in partition #${pa} for ${stage}";
	     else
		Message="${Message} and looks on boot drive #${dr} in partition #${pa} for ${stage}";
	     fi
	  fi;;

    eb4c) ## Grub2 (v1.96) is in the MBR. ##
	  BL='Grub2 (v1.96)';

	  grub2_info ${drive} ${drive} '1.96' 'disk';

	  Message="${Message} and ${Grub2_Msg}";;

    eb63) ## Grub2 is in the MBR. ##
	  case ${MBR_bytes80to81} in
		7c3c) grub2_version='1.97-1.98'; BL='Grub2 (v1.97-1.98)';;
		0020) grub2_version='1.99-2.00'; BL='Grub2 (v1.99-2.00)';;
	  esac

	  grub2_info ${drive} ${drive} ${grub2_version} 'disk';

	  # Set a more exact version number (1.99 or 2.00), if '1.99-2.00' was
	  # passed to the grub2_info function.
	  BL="Grub2 (v${grub2_version})";

	  Message="${Message} and ${Grub2_Msg}";;

    0ebe) BL='ThinkPad';;
    31c0) # Look at the first 8 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig8} in
	    31c08ed0bc007c8e) BL='NetBSD/SUSE generic MBR';;
	    31c08ed0bc007cfb) BL='Acer PQService MBR';;
	  esac;;
    33c0) # Look at the first 3 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig3} in
	    33c08e) BL='Windows';
		    case ${MBR_sig8} in
		      33c08ed0bc007cfb) BL='Windows 2000/XP/2003';;
		      33c08ed0bc007c8e)
					# Look at byte 0xF0-F1: different offset for "TCPA" string.
					case "${MBR_512:480:4}" in
					  fb54) BL='Windows Vista';;
					  4350) BL='Windows 7/8/2012';;
					esac;;
		    esac;;
	    33c090) BL='DiskCryptor';;
	    33c0fa) # Look at bytes 0x5B-5D: different offsets for jump target
	      case ${MBR_512:182:6} in
		0fb6c6) BL='Syslinux GPTMBR (5.10 and higher)';;
		bb007c) BL='Syslinux GPTMBR (4.04-5.01)';;
		e82101) BL='Syslinux MBR (4.04-4.07)';;
		e83501) BL='Syslinux MBR (5.00 and higher)';;
		e81001) # Syslinux ALTMBR; look at byte 0xd9 for different version and
			# byte 0x1b7 (439) for boot partition
		  case ${MBR_512:434:2} in
		    c3) BL='Syslinux ALTMBR (4.04-4.05)';;
		    c6) BL='Syslinux ALTMBR (4.06 and higher)';;
		  esac;
		  BL="${BL} with boot partition 0x${MBR_512:878:2}";;
	      esac;;
	  esac;;
    33ed) # Look at bytes 0x80-0x81 to be more specific about the Syslinux variant/version.
	  case ${MBR_bytes80to81} in
	    407c) BL='ISOhybrid (Syslinux 4.04)';;
	    83e1) BL='ISOhybrid with partition support (Syslinux 4.04)';;
	    cd13) BL='ISOhybrid with partition support (Syslinux 4.05 and higher)';;
	    f7e1) BL='ISOhybrid (Syslinux 4.05 and higher)';;
	  esac;;
    33ff) BL='HP/Gateway';;
    b800) BL='Plop';;
    ea05)
	  case ${MBR_sig3} in
	    ea0500) BL='OpenBSD generic MBR';;
	    ea0501) BL='XOSL';;
	  esac;;
    ea1e) BL='Truecrypt Boot Loader';;
    eb04) BL='Solaris';;
    eb31) BL='Paragon';;
    eb5e) # Look at the first 3 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig3} in
	    eb5e00) BL='fbinst';;
	    eb5e80) BL='Grub4Dos';;
	    eb5e90) BL='WEE';
		    # Get the embedded menu of WEE.
		    get_embedded_menu "${drive}" "WEE's (${drive})";;
	  esac;;
    fa31) # Look at the first 3 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig3} in
	    fa31c0) # Look at bytes 0x80-0x81 to be more specific about the Syslinux variant/version.
		    case ${MBR_bytes80to81} in
		      0069) BL='ISOhybrid (Syslinux 3.72-3.73)';;
		      7c66) BL='Syslinux MBR (3.61-4.03)';;
		      7cb8) BL='Syslinux MBR (3.36-3.51)';;
		      b442) BL='Syslinux MBR (3.00-3.35)';;
		      bb00) BL='Syslinux MBR (3.52-3.60)';;
		      e2f8) # Syslinux pre-4.04; look at bytes 0x82-0x84
		            case "${MBR_512:260:6}" in
			      31f65f) BL='Syslinux GPTMBR (4.00-4.03)';;
			      5e5974) BL='Syslinux GPTMBR (3.72-3.73)';;
			      5e5958) # look at bytes 0xe-0xf
			              case "${MBR_512:28:4}" in
				        528e) BL='Syslinux GPTMBR (3.70-3.71)';;
				        8ec0) BL='Syslinux GPTMBR (3.74-4.03)';;
				      esac;;
			    esac;;
		      e879) BL='ISOhybrid (Syslinux 3.74-3.80)';;
		    esac;;
	    fa31c9) BL='Master Boot LoaDeR';;   
	    fa31ed) # Look at bytes 0x80-0x81 to be more specific about the Syslinux variant/version.
		    case ${MBR_bytes80to81} in
		      0069) BL='ISOhybrid (Syslinux 3.72-3.73)';;
		      0fb6) BL='ISOhybrid with partition support (Syslinux 3.82-3.86)';;
		      407c) BL='ISOhybrid (Syslinux 3.82-4.03)';;
		      83e1) BL='ISOhybrid with partition support (Syslinux 4.00-4.03)';;
		      b6c6) BL='ISOhybrid with partition support (Syslinux 3.81)';;
		      fbc0) BL='ISOhybrid (Syslinux 3.81)';;
		    esac;;
	  esac;;
    fa33) BL='MS-DOS 3.30 through Windows 95 (A)';;
    fab8) # Look at the first 4 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig4} in
	    fab80000) BL='FreeDOS (eXtended FDisk)';;
	    fab80010) BL="libparted MBR boot code";;
	  esac;;
    faeb) BL='Lilo';; 
    fafc) BL='ReactOS';;
    fc31) # Look at the first 8 bytes of the hard drive to identify the boot code installed in the MBR.
	  case ${MBR_sig8} in
	    fc31c08ed031e48e) BL='install-mbr/Testdisk';;
	    fc31c08ec08ed88e) BL='boot0 (FreeBSD)';;
	  esac;;
    fc33) BL='GAG';;
    fceb) BL='BootIt NG';;
    0000) BL='No boot loader';;
  esac

  if [ x"${BL}" = 'x' ] ; then
     BL='No known boot loader';
     printf "Unknown MBR on ${drive}\n\n" >> ${Unknown_MBR};
     hexdump -v -n 512 -C ${drive} >> ${Unknown_MBR};
     echo >> ${Unknown_MBR};
  fi


  ## Output message at beginning of summary that gives MBR info for each drive: ##

  printf ' => ' >> "${Log}";
  printf "${BL} ${Message}.\n" | fold -s -w 75 | sed -e '/^-----\.\?$/ d' -e '2~1s/.*/    &/' >> "${Log}";

  HDMBR[${HI}]=${BL};
done

echo >> "${Log}";

## Write a final newline. ##

echo >> "${Log}";



if [ ${stdout_output} -eq 1 ] ; then
   ## If --stdout is specified, show the output.
   cat "${Log}";
fi

exit 0;

